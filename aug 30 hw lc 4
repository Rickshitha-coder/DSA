Date : 30/8/2025
Reverse Linked List II
Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.
 
Example 1:
 
Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]
Example 2:
Input: head = [5], left = 1, right = 1
Output: [5]
 
Constraints:
•	The number of nodes in the list is n.
•	1 <= n <= 500
•	-500 <= Node.val <= 500
•	1 <= left <= right <= n
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null || left == right) return head;

        // Step 1: Dummy node before head
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // Step 2: Move `prev` to the node before `left`
        ListNode prev = dummy;
        for (int i = 1; i < left; i++) {
            prev = prev.next;
        }

        // Step 3: Reverse sublist [left, right]
        ListNode curr = prev.next;
        ListNode next = null, prevSub = null;

        for (int i = left; i <= right; i++) {
            next = curr.next;
            curr.next = prevSub;
            prevSub = curr;
            curr = next;
        }

        // Step 4: Connect reversed sublist back
        prev.next.next = curr; // tail connects to remainder
        prev.next = prevSub;   // prev connects to new head of sublist

        return dummy.next;
    }
}


            prev = curr;                   // move prev
            curr = nextNode;               // move curr
        }

        return prev; // new head
    }
}




